C51 COMPILER V9.59.0.0   CLOCK                                                             08/18/2025 16:47:43 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE clock.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\clo
                    -ck.lst) TABS(2) OBJECT(.\Objects\clock.obj)

line level    source

   1          #include <reg51.h>
   2          
   3          // ===== LCD Connections =====
   4          #define lcd_data P1
   5          sbit RS = P2^0;
   6          sbit RW = P2^1;
   7          sbit EN = P2^2;
   8          
   9          // ===== I2C Connections =====
  10          sbit SDA = P3^3;
  11          sbit SCL = P3^2;
  12          
  13          #define DS1307_ID 0xD0  // 11010000 (write)
  14          
  15          // ===== Delay =====
  16          void delay(unsigned int ms) {
  17   1          unsigned int i, j;
  18   1          for(i=0; i<ms; i++)
  19   1              for(j=0; j<1275; j++);
  20   1      }
  21          
  22          // ===== LCD Functions =====
  23          void lcd_cmd(unsigned char cmd) {
  24   1          RS = 0; RW = 0;
  25   1          lcd_data = cmd;
  26   1          EN = 1; delay(2); EN = 0;
  27   1      }
  28          
  29          void lcd_char(unsigned char val) {
  30   1          RS = 1; RW = 0;
  31   1          lcd_data = val;
  32   1          EN = 1; delay(2); EN = 0;
  33   1      }
  34          
  35          void lcd_string(char *s) {
  36   1          while(*s) lcd_char(*s++);
  37   1      }
  38          
  39          void lcd_init() {
  40   1          lcd_cmd(0x38); // 2 line, 5x7 matrix
  41   1          lcd_cmd(0x0C); // Display on, cursor off
  42   1          lcd_cmd(0x01); // Clear
  43   1          lcd_cmd(0x80); // First line
  44   1      }
  45          
  46          // Print 2-digit numbers (e.g. 01, 09, 12)
  47          void lcd_show_num(unsigned char num) {
  48   1          lcd_char((num/10) + '0');
  49   1          lcd_char((num%10) + '0');
  50   1      }
  51          
  52          // ===== I2C Functions =====
  53          void i2c_start() {
  54   1          SDA = 1; SCL = 1; delay(1);
C51 COMPILER V9.59.0.0   CLOCK                                                             08/18/2025 16:47:43 PAGE 2   

  55   1          SDA = 0; delay(1);
  56   1          SCL = 0;
  57   1      }
  58          
  59          void i2c_stop() {
  60   1          SDA = 0; SCL = 1; delay(1);
  61   1          SDA = 1; delay(1);
  62   1      }
  63          
  64          void i2c_write(unsigned char dat) {
  65   1          unsigned char i;
  66   1          for(i=0; i<8; i++) {
  67   2              SDA = (dat & 0x80) ? 1 : 0;
  68   2              SCL = 1; delay(1);
  69   2              SCL = 0; delay(1);
  70   2              dat <<= 1;
  71   2          }
  72   1          SDA = 1; SCL = 1; delay(1); // ACK
  73   1          SCL = 0;
  74   1      }
  75          
  76          unsigned char i2c_read(unsigned char ack) {
  77   1          unsigned char i, dat=0;
  78   1          SDA = 1; // Release SDA
  79   1          for(i=0; i<8; i++) {
  80   2              SCL = 1; delay(1);
  81   2              dat = (dat<<1) | SDA;
  82   2              SCL = 0; delay(1);
  83   2          }
  84   1          SDA = (ack) ? 0 : 1; // ACK for more, NACK for last
  85   1          SCL = 1; delay(1); SCL = 0;
  86   1          SDA = 1;
  87   1          return dat;
  88   1      }
  89          
  90          // ===== RTC Functions =====
  91          unsigned char rtc_read(unsigned char addr) {
  92   1          unsigned char dat;
  93   1          i2c_start();
  94   1          i2c_write(DS1307_ID);     // Write mode
  95   1          i2c_write(addr);          // Address
  96   1          i2c_start();
  97   1          i2c_write(DS1307_ID | 1); // Read mode
  98   1          dat = i2c_read(0);
  99   1          i2c_stop();
 100   1          return dat;
 101   1      }
 102          
 103          void rtc_write(unsigned char addr, unsigned char dat) {
 104   1          i2c_start();
 105   1          i2c_write(DS1307_ID); // Write mode
 106   1          i2c_write(addr);
 107   1          i2c_write(dat);
 108   1          i2c_stop();
 109   1      }
 110          
 111          void rtc_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
 112   1          rtc_write(0x00, ((sec/10)<<4) | (sec%10));   // Seconds BCD
 113   1          rtc_write(0x01, ((min/10)<<4) | (min%10));   // Minutes BCD
 114   1          rtc_write(0x02, ((hr/10)<<4) | (hr%10));     // Hours BCD
 115   1      }
 116          
C51 COMPILER V9.59.0.0   CLOCK                                                             08/18/2025 16:47:43 PAGE 3   

 117          // Convert BCD ? Decimal
 118          unsigned char BCD_DEC(unsigned char val) {
 119   1          return ((val >> 4) * 10 + (val & 0x0F));
 120   1      }
 121          
 122          // ===== Main =====
 123          void main() {
 124   1          unsigned char sec, min, hour;
 125   1          unsigned char last_sec = 0xFF;
 126   1      
 127   1          lcd_init();
 128   1          lcd_cmd(0x80);
 129   1          lcd_string("Time: ");
 130   1      
 131   1          // Set time once ? 12:00:00
 132   1          rtc_set_time(12, 0, 0);
 133   1      
 134   1          while(1) {
 135   2              sec  = BCD_DEC(rtc_read(0x00) & 0x7F);
 136   2              min  = BCD_DEC(rtc_read(0x01) & 0x7F);
 137   2              hour = BCD_DEC(rtc_read(0x02) & 0x3F);
 138   2      
 139   2              if(sec != last_sec) {  // Update only when sec changes
 140   3                  lcd_cmd(0x86);
 141   3                  lcd_show_num(hour);
 142   3                  lcd_char(':');
 143   3                  lcd_show_num(min);
 144   3                  lcd_char(':');
 145   3                  lcd_show_num(sec);
 146   3                  last_sec = sec;
 147   3              }
 148   2      
 149   2              delay(50);
 150   2          }
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    561    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
